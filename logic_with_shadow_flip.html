<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Memory & Shadow Games</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f4f4f9;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    .game-container h1 {
      margin: 0;
      font-size: 2rem;
      color: #333;
    }
    .game-container .options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      justify-items: center;
    }
    .game-container .option {
      width: 100px;
      height: 100px;
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s;
    }
    .game-container .option img {
      width: 100%;
      height: 100%;
      object-fit: contain; /* fixed to show entire image */
      display: block;
      transition: opacity 0.3s;
    }
    .game-container .option.flipped img {
      opacity: 0;
    }
    .game-container .option.matched {
      transform: scale(1.1);
      box-shadow: 0 6px 8px rgba(0, 255, 0, 0.3);
    }
    .game-container .option-back {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #333;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.5rem;
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .game-container .option.flipped .option-back {
      opacity: 1;
    }
    .game-container .option.matched .option-back {
      background-color: green;
    }
  </style>
</head>
<body>

<div class="game-container">
  <h1>Memory & Shadow Games</h1>
  <div class="options" id="memory-game">
    <!-- Memory game options will be injected here -->
  </div>
  <div class="options" id="shadow-game">
    <!-- Shadow game options will be injected here -->
  </div>
</div>

<script>
  const memoryImages = [
    'image1.jpg',
    'image2.jpg',
    'image3.jpg',
    'image4.jpg',
    'image5.jpg',
    'image6.jpg'
  ];

  const shadowImages = [
    'image1.jpg',
    'image2.jpg',
    'image3.jpg',
    'image4.jpg',
    'image5.jpg',
    'image6.jpg'
  ];

  const memoryGame = document.getElementById('memory-game');
  const shadowGame = document.getElementById('shadow-game');

  function createMemoryGame() {
    const shuffledImages = [...memoryImages, ...memoryImages]
      .sort(() => Math.random() - 0.5);
    shuffledImages.forEach(src => {
      const option = document.createElement('div');
      option.classList.add('option');
      option.dataset.name = src;

      const img = document.createElement('img');
      img.src = src;
      img.alt = src;

      const optionBack = document.createElement('div');
      optionBack.classList.add('option-back');
      optionBack.textContent = '?';

      option.appendChild(img);
      option.appendChild(optionBack);
      memoryGame.appendChild(option);
    });
  }

  function createShadowGame() {
    shadowImages.forEach(src => {
      const option = document.createElement('div');
      option.classList.add('option');
      option.dataset.name = src;

      const img = document.createElement('img');
      img.src = src;
      img.alt = src;

      const optionBack = document.createElement('div');
      optionBack.classList.add('option-back');
      optionBack.textContent = '?';

      option.appendChild(img);
      option.appendChild(optionBack);
      shadowGame.appendChild(option);
    });
  }

  function convertToSilhouette(img) {
    return new Promise(resolve => {
      const tempImg = new Image();
      tempImg.crossOrigin = "anonymous"; // in case images are external
      tempImg.src = img.src;
      tempImg.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.clientWidth;   // use clientWidth to fit box
        canvas.height = img.clientHeight;
        ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
          const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
          const threshold = 128;
          const color = avg < threshold ? 0 : 255;
          data[i] = data[i + 1] = data[i + 2] = color;
        }

        ctx.putImageData(imageData, 0, 0);
        resolve(canvas.toDataURL());
      };
    });
  }

  async function handleShadowClick(event) {
    const option = event.currentTarget;
    if (option.classList.contains('flipped')) return;

    option.classList.add('flipped');
    const img = option.querySelector('img');
    const silhouette = await convertToSilhouette(img);
    img.src = silhouette;
  }

  function handleMemoryClick(event) {
    const option = event.currentTarget;
    if (option.classList.contains('flipped') || option.classList.contains('matched')) {
      return;
    }

    option.classList.add('flipped');
    const flippedOptions = document.querySelectorAll('.option.flipped');
    if (flippedOptions.length === 2) {
      const [first, second] = flippedOptions;
      if (first.dataset.name === second.dataset.name) {
        first.classList.add('matched');
        second.classList.add('matched');
      }
      setTimeout(() => {
        flippedOptions.forEach(opt => opt.classList.remove('flipped'));
      }, 1000);
    }
  }

  memoryGame.addEventListener('click', event => {
    if (event.target.closest('.option')) {
      handleMemoryClick(event);
    }
  });

  shadowGame.addEventListener('click', event => {
    if (event.target.closest('.option')) {
      handleShadowClick(event);
    }
  });

  createMemoryGame();
  createShadowGame();
</script>

</body>
</html>
